const ffmpeg = require('fluent-ffmpeg')
const path = require('path')
const isDev = process.env.NODE_ENV === 'development';
import { createWriteStream, mkdirSync, readFile } from 'fs'//, writeFile unlinkSync
import { resolve } from 'path'
import { platform, arch } from 'os'
import { app, dialog } from 'electron'

export interface subtitleData {
  startSeconds: number
  endSeconds: number
  text1: string
  text2: string
  isFirst: boolean
}

export interface VideoData {
  videoMode: number
  subtitles: subtitleData[]
  interview_id: number
}

function secondsToString(seconds: number): string {
  // 00:00:00,000
  const hours = Math.floor(seconds / 3600)
  const minutes = Math.floor((seconds % 3600) / 60)
  const remainingSeconds = seconds % 60
  const milliseconds = Math.floor((remainingSeconds % 1) * 1000)
  return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${Math.floor(remainingSeconds).toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`
}

function generateASS(subtitles: subtitleData[]): string {
  let currentIndex = 1;
  const assHeader = `
[Script Info]
; Script generated by YourApp
Title: Interview Subtitles
ScriptType: v4.00+
Collisions: Normal
PlayResX: 1920
PlayResY: 1080

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Centered,Arial,80,&H00000000,&H000000FF,&H00000000,&H64000000,0,0,0,0,100,100,0,0,1,0,0,5,10,10,10,1
Style: TopCentered,Arial,50,&H00FFFFFF,&H000000FF,&H00000000,&H64000000,0,0,0,0,100,100,0,0,1,0,0,8,10,10,50,1


[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

  const assEntries: string[] = [];

  subtitles.forEach(subtitle => {
    const processedText1 = subtitle.text1.replace(/\r?\n/g, '\\N');
    const processedText2 = subtitle.text2 ? subtitle.text2.replace(/\r?\n/g, '\\N') : '';
    if (subtitle.isFirst) {
      // 첫 5초 동안 text1과 text2를 모두 표시
      assEntries.push(
        `Dialogue: 0,${secondsToString(subtitle.startSeconds)},${secondsToString(subtitle.startSeconds + 5)},Centered,,0,0,0,,{\\b1}${processedText1}{\\fs15}\\N\\N{\\fs50\\b0}${processedText2 || ''}`
      );
      currentIndex++;

      // 나머지 시간 동안 text1만 표시
      assEntries.push(
        `Dialogue: 0,${secondsToString(subtitle.startSeconds + 5)},${secondsToString(subtitle.endSeconds)},TopCentered,,0,0,0,,{\\b1}${processedText1}`
      );
      currentIndex++;
    } else {
      // 일반 자막, 화면 상단 중앙 배치
      assEntries.push(
        `Dialogue: 0,${secondsToString(subtitle.startSeconds)},${secondsToString(subtitle.endSeconds)},TopCentered,,0,0,0,,{\\b1}${processedText1}`
      );
      currentIndex++;
    }
  });

  return assHeader + assEntries.join('\n');
}

export async function processVideoFile({
  originalFileBuffer,
  originalFileName,
  subtitles,
  videoMode,
}: {
  originalFileBuffer: Buffer
  originalFileName: string
  subtitles: subtitleData[]
  videoMode?: number
}): Promise<Buffer> {
  const platformName = `${platform()}-${arch()}`
  const ffmpegPath =
    isDev === true
      ? path.join(
          __dirname,
          '../../resources',
          'ffmpeg-bin',
          platformName,
          `ffmpeg${platform() === 'win32' ? '.exe' : ''}`
        )
      : path.join(
          process.resourcesPath,
          'resources',
          'ffmpeg-bin',
          platformName,
          `ffmpeg${platform() === 'win32' ? '.exe' : ''}`
        )
  ffmpeg.setFfmpegPath(ffmpegPath)



  const tempCode = new Date().toLocaleDateString('ko-KR',
    { year: 'numeric', month: '2-digit', day: '2-digit'})
      .replace(/[^0-9]/g, '')
      .replace(/\s/g, '')
      .slice(0, 8)

  const localTime = new Date().toLocaleTimeString('ko-KR', {
    hour: '2-digit',
    minute: '2-digit',
    hour12: false
  }).replace(':', '')
  
  const tempDir = (process.platform==='win32') ? `../../innerview-downloads/${tempCode}` : path.join(app.getPath('downloads'), tempCode)
  mkdirSync(tempDir,{ recursive: true })

  const inputFileName = (process.platform==='win32') ? (tempDir +'/'+ originalFileName) : resolve(tempDir, originalFileName)
  const outputFileName = (process.platform==='win32') ? (tempDir +'/'+ 'output.mp4') : resolve(tempDir, 'output.mp4')
  const backgroundOtherPath = isDev === true ?
                            path.join(__dirname, '../../src/renderer/src/assets/images/watermark.png') 
                            : path.join(process.resourcesPath, 'resources', 'assets', 'images', 'watermark.png');  // Prod 모드
  const backgroundFirstPath = isDev === true ?
                            path.join(__dirname, '../../src/renderer/src/assets/images/watermark_first.png') 
                            : path.join(process.resourcesPath, 'resources', 'assets', 'images', 'watermark_first.png');  // Prod 모드

  await new Promise<void>((resolve, reject) => {
    const inputWriteStream = createWriteStream(inputFileName)
    inputWriteStream.write(originalFileBuffer)
    inputWriteStream.end()
    inputWriteStream.on('finish', resolve)
    inputWriteStream.on('error', reject)
  })

  // 자막 파일 생성

  const assContent = generateASS(subtitles);

  // 배경 이미지 경로 설정
  const subtitleFileName = (process.platform === 'win32') 
  ? `${tempDir}/${localTime}subtitles.ass` 
  : resolve(tempDir, `${localTime}subtitles.ass`);

  const assFilePath = await new Promise<string>((resolvePath, reject) => {
    const subtitleWriteStream = createWriteStream(subtitleFileName, {
      encoding: 'utf-8',
    });

    subtitleWriteStream.write(assContent);
    subtitleWriteStream.end();

    subtitleWriteStream.on('finish', () => {
      resolvePath(subtitleFileName);
    });

    subtitleWriteStream.on('error', (err) => {
      reject(err);
    });
  });

  // 배경 이미지까지 처리 후 기본 자막 및 자막 배경 설정
  const firstSubtitleTimes = subtitles
  .filter(sub => sub.isFirst)
  .map(sub => ({
    start: sub.startSeconds,
    end: sub.startSeconds + 5,
  }));

  // 그 외 자막 배경 이미지 오버레이 시간대 추출
  const otherSubtitleTimes1 = subtitles
    .filter(sub => !sub.isFirst)
    .map(sub => ({
      start: sub.startSeconds,
      end: sub.endSeconds,
    }));
  const otherSubtitleTimes2 = subtitles
    .filter(sub => sub.isFirst)
    .map(sub => ({
      start: sub.startSeconds+5,
      end: sub.endSeconds,
    }));
  const otherSubtitleTimes = [...otherSubtitleTimes1, ...otherSubtitleTimes2];

  // FFmpeg 필터 그래프 설정
  const filterGraph: Array<{
    filter: string;
    options: any;
    inputs: string | string[];
    outputs: string;
  }> = [];
  // isFirst 배경 이미지 오버레이

  firstSubtitleTimes.forEach((time, index) => {
    filterGraph.push({
      filter: 'overlay',
      options: {
        enable: `between(t,${time.start},${time.end})`,
        x: '0',
        y: '0'
      },
      inputs: [index === 0 ? 'filteredVideo' : `v_first_${index - 1 }`, '1:v'],
      outputs: `v_first_${index}`
    });
  });

  // 그 외 배경 이미지 오버레이
  otherSubtitleTimes.forEach((time, index) => {
    const prevStream = firstSubtitleTimes.length > 0 ? `v_first_${firstSubtitleTimes.length - 1}` : 'filteredVideo';
    filterGraph.push({
      filter: 'overlay',
      options: {
        enable: `between(t,${time.start},${time.end})`,
        x: '0',
        y: '0'
      },
      inputs: [index === 0 ? prevStream :`v_other_${index - 1}`, '2:v'],
      outputs: `v_other_${index}`
    });
  });

  // ASS 자막 적용 (최종 스트림에 자막을 오버레이하여 최상위에 표시)
  const finalStream = otherSubtitleTimes.length > 0
    ? `v_other_${otherSubtitleTimes.length - 1}`
    : firstSubtitleTimes.length > 0
      ? `v_first_${firstSubtitleTimes.length - 1}`
      : 'filteredVideo:v';

  filterGraph.push({
    filter: 'ass',
    options: {
      filename: assFilePath
    },
    inputs: finalStream,
    outputs: 'v_final_with_subtitles'
  });


  const commonFilters =[
    [
      {
      filter: 'hflip',  // 좌우 반전 필터
      inputs: '[0:v]',
      outputs: 'flippedRawVideo'
      }
    ],
    [
    {
      filter: 'format',
      options: 'yuv420p',  // 최종 색상 포맷 정상화
      inputs: 'v_final_with_subtitles',
      outputs: 'outputVideo'
    }]
  ]
  const complexFilter = [
    [ // 0. Original Filter
      {
      filter: 'null',
      inputs: 'flippedRawVideo',
      outputs: 'filteredVideo'
      }
    ],
    [ // 1. Black&White Filter
      {
        filter: 'format',
        options: 'gray',
        inputs: 'flippedRawVideo',
        outputs: 'filteredVideo'
      }
    ],
    [ // 2. Vintage 1 Filter
      // 세피아 효과
      {
        filter: 'colorchannelmixer',
        options: {
          rr: 0.8179, // (0.393 * 0.3) + (1 * 0.7)
          rg: 0.2307, // (0.769 * 0.3) + (0 * 0.7)
          rb: 0.0567, // (0.189 * 0.3) + (0 * 0.7)
          gr: 0.1047, // (0.349 * 0.3) + (0 * 0.7)
          gg: 0.9058, // (0.686 * 0.3) + (1 * 0.7)
          gb: 0.0504, // (0.168 * 0.3) + (0 * 0.7)
          br: 0.0816, // (0.272 * 0.3) + (0 * 0.7)
          bg: 0.1602, // (0.534 * 0.3) + (0 * 0.7)
          bb: 0.7393, // (0.131 * 0.3) + (1 * 0.7)
          aa: 1       // 알파 채널 (투명도), 일반적으로 변경하지 않음
        },
        inputs: 'flippedRawVideo',
        outputs: 'firstFilteredVideo'
      },
      // 밝기, 대비, 채도 조정
      {
        filter: 'eq',
        options: {
          contrast: 0.8,
          brightness: 0.2, // CSS의 1.2는 ffmpeg에서 기준값 1에서 0.2 증가
          saturation: 2
        },
        inputs: 'firstFilteredVideo',
        outputs: 'filteredVideo'
      }
    ],
    
    [ // 3. Vintage 2 Filter
      // 세피아 효과
      {
        filter: 'colorchannelmixer',
        options: '0.472:0.858:0.234:0:0.393:0.769:0.189:0:0.272:0.534:0.131:0',
        inputs: 'flippedRawVideo',
        outputs: 'firstFilteredVideo'
      },
      // 밝기, 대비, 채도 조정
      {
        filter: 'eq',
        options: {
          brightness: 0.1,  // +0.1 밝기 증가
          contrast: 1.2,    // 대비 증가
          saturation: 0.9,  // 채도 약간 감소
        },
        inputs: 'firstFilteredVideo',
        outputs: 'secondFilteredVideo'
      },
      // 색상 회전
      {
        filter: 'hue',
        options: 'h=-10', // -10도 회전
        inputs: 'secondFilteredVideo',
        outputs: 'filteredVideo'
      }
    ]
  ];
  const finalFilter = [...commonFilters[0], ...complexFilter[videoMode ?? 0], ...filterGraph, ...commonFilters[1]]

  return new Promise<Buffer>((resolve, reject) => {
    ffmpeg(inputFileName)
      .input(backgroundFirstPath)
      .input(backgroundOtherPath)
      // .inputOptions('-hwaccel auto') // 하드웨어 가속을 입력 옵션으로 설정 -> 쓰고 싶다면 mac에서 h264_videotoolbox를 쓰고 싶다면 이 옵션을 사용

      .complexFilter(finalFilter)

      .videoCodec('libx264') // .videoCodec('h264_videotoolbox') 을 고려해봐도 좋음
      .audioCodec('aac') // 오디오 코덱을 aac로 설정
      
      .output(outputFileName)
      .outputOptions([
        '-preset fast',     // 인코딩 속도/품질 균형
        '-movflags +faststart', // MP4 헤더 스트리밍 최적화
        '-async 1',         // 싱크 문제 해결
        '-ac 2',            // 스테레오 오디오
        '-ar 44100',         // 오디오 샘플레이트 44100Hz
        '-map [outputVideo]',// 필터링된 비디오 스트림 매핑
        '-map 0:a',          // 원본 오디오 스트림 매핑
        '-strict -2'         // FFmpeg 일부 경고 무시
      ])
      .on('start', (commandLine) => {
      console.log('FFmpeg command:', commandLine)
      })
      .on('stderr', (stderrLine) => {
        console.error('FFmpeg stderr:', stderrLine);
      })      
      .on('error', (err: Error) => {
        dialog.showErrorBox('FFmpeg Error', `FFmpeg Error: ${err.message}\nCommand: ${err.stack}`);
        reject(err);
      })
      .on('progress', (progress: { percent?: number }) => {
        const percentage = progress.percent ?? 0; // Set to 0 if percent is undefined
        console.log(`Processing: ${percentage}% done`);
      })
      .on('end', () => {
      readFile(outputFileName, (err, data) => {
        if (err) {
        dialog.showErrorBox('Read File Error', err.message)
        reject(err)
        } else {
        // ;[inputFileName, subtitleFileName, outputFileName].forEach((file) => {
        //   try {
        //   unlinkSync(file) // 위에 import도 취소해둠
        //   } catch (err) {
        //   dialog.showErrorBox('Delete File Error', (err as Error).message)
        //   }
        // })

        resolve(data)
        }
      })
      })
      .run()
  })
}